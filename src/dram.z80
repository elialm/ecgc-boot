include "boot.inc"
include "ecgc_cart.inc"
include "hardware.inc"
include "macros.inc"

; DRAM_TEST_UPPER_BANK = $07FF
DRAM_TEST_UPPER_BANK = $0010
DRAM_TEST_BANK_SIZE = $4000

section "DRAM routines", rom0

dram_start_test::
    ; Halt till next VBlank, then disable LCD
    halt
    nop
    ld hl, rLCDC
    res 7, [hl]

    ; Scroll history and empty line
    call scroll_history
    LOAD_CELL_SCRN0_HL 1, 1
    ld d, 9
    xor a, a
    call memset
    call scroll_history

    ; Print read progress line
    LOAD_CELL_SCRN0_HL 1, 1
    ld a, "R"
    ld [hl+], a
    ld a, "B"
    ld [hl+], a
    inc hl
    ld a, "0"
    ld d, 4
    call memset

    ; Scroll history to lower read progress line
    call scroll_history

    ; Print write progress line
    LOAD_CELL_SCRN0_HL 1, 1
    ld a, "W"
    ld [hl], a

    ; Scroll history to lower write progress line
    call scroll_history

    ; Print zero progress line
    LOAD_CELL_SCRN0_HL 1, 1
    ld a, "0"
    ld [hl], a

    ; Enable LCD
    ld hl, rLCDC
    set 7, [hl]

    ; TODO: call test loop several times

    ; Initialise rand routine
    ld a, [dram_test_rand_seed]
    call rand_init

    ; Run random write loop
    LOAD_CELL_SCRN0_BC 4, 2
    ld de, dram_test_random_write
    call dram_test_loop

    ret

; Perform a DRAM test loop
; This will jump to a given routine once for each DRAM bank
; bc - screen location to update the bank counter with
; de - pointer to bank routine
;
; WARNING: the bank routine must not call ret, but jp to
; dram_test_loop.bank_routine_ret
dram_test_loop:
    ; Push arguments to the stack for later use
    push bc
    push de

    ; Initialise loop counter
    xor a, a
    ldh [bank_counter], a
    ldh [bank_counter+1], a

.bank_loop:
    ; Set DRAM bank
    ld a, [bank_counter]
    ld [CART_DRAM_SEL0], a
    ld a, [bank_counter+1]
    and a, %00000111
    ld [CART_DRAM_SEL1], a

    ; Update loop status
    LCD_DISABLE

    ; Load bank counter screen location to hl
    ld hl, sp+2
    ld a, [hl+]
    ld b, a
    ld h, [hl]
    ld l, b

    ; Print bank_counter high byte
    ld a, [bank_counter+1]
    ld d, a
    call d2hex
    ld [hl], b
    inc hl
    ld [hl], c
    inc hl

    ; Print bank_counter low byte
    ld a, [bank_counter]
    ld d, a
    call d2hex
    ld [hl], b
    inc hl
    ld [hl], c

    LCD_ENABLE

    ; Call bank routine pointer stored on the stack
    ld hl, sp+0
    ld a, [hl+]
    ld b, a
    ld h, [hl]
    ld l, b
    jp hl
.bank_routine_ret:

    ; Increment bank counter and check if bank loop still needs to run
    ld hl, bank_counter
    inc [hl]    
    jr nz, .skip_upper_inc
    inc hl
    inc [hl]
    dec hl
.skip_upper_inc:
    ; incremented bank counter is stored to ram
    inc hl
    ld a, high(DRAM_TEST_UPPER_BANK)
    cp a, [hl]
    jr nz, .bank_loop
    dec hl
    ld a, low(DRAM_TEST_UPPER_BANK)
    cp a, [hl]
    jr nz, .bank_loop

    ; Pop arguments from the stack
    pop de
    pop bc

    ret

dram_test_random_write:
    ; Set DRAM pointer
    ld l, $00
    ld h, $40

    ; Fill bank with random data
    ld d, high(DRAM_TEST_BANK_SIZE)
    ld e, low(DRAM_TEST_BANK_SIZE)
.rng_loop:
    call rand
    ld [hl+], a
    dec de
    xor a, a
    cp a, d
    jr nz, .rng_loop
    cp a, e
    jr nz, .rng_loop

    jp dram_test_loop.bank_routine_ret

; Random number seed
dram_test_rand_seed:
    db $6E

section "DRAM routines variables", hram

bank_counter:
    ds 2
include "hardware.inc"
include "macros.inc"

; For EFB functions, refer to Using Hardend Control Functions MachXO3D Reference
; https://www.latticesemi.com/-/media/LatticeSemi/Documents/ApplicationNotes/UZ/FPGA-TN-02119-1-3-Using-Hardened-Control-Functions-MachXO3D-Reference.ashx?document_id=52704

; EFB Base address (might change upon firmware revision)
CART_EFB_BASE       equ $A000

; EFB SPI Registers
CART_EFB_SPICR0     equ (CART_EFB_BASE + $54)   ; EFB SPI Control Register 0
CART_EFB_SPICR1     equ (CART_EFB_BASE + $55)   ; EFB SPI Control Register 1
CART_EFB_SPICR2     equ (CART_EFB_BASE + $56)   ; EFB SPI Control Register 2
CART_EFB_SPIBR      equ (CART_EFB_BASE + $57)   ; EFB SPI Clock Pre-scale
CART_EFB_SPICSR     equ (CART_EFB_BASE + $58)   ; EFB SPI Chip Select
CART_EFB_SPITXDR    equ (CART_EFB_BASE + $59)   ; EFB SPI Transmit Data
CART_EFB_SPISR      equ (CART_EFB_BASE + $5A)   ; EFB SPI Status Register
CART_EFB_SPIRXDR    equ (CART_EFB_BASE + $5B)   ; EFB SPI Revieve Data
CART_EFB_SPIIRQ     equ (CART_EFB_BASE + $5C)   ; EFB SPI Interrupt Request
CART_EFB_SPIIRQEN   equ (CART_EFB_BASE + $5D)   ; EFB SPI Interrupt Request Enable

; EFB Flash Registers

; EFB Flash Control
CART_EFB_CFGCR      equ (CART_EFB_BASE + $70)
CART_EFB_CFGCR_WBCE equ 7   ; WISHBONE Connection Enable
CART_EFB_CFGCR_RSTE equ 6   ; WISHBONE Connection Reset

CART_EFB_CFGTXDR    equ (CART_EFB_BASE + $71)   ; EFB Flash Transmit Data
CART_EFB_CFGSR      equ (CART_EFB_BASE + $72)   ; EFB Flash Status
CART_EFB_CFGRXDR    equ (CART_EFB_BASE + $73)   ; EFB Flash Recieve Data
CART_EFB_CFGIRQ     equ (CART_EFB_BASE + $74)   ; EFB Flash Interrupt Request
CART_EFB_CFGIRQEN   equ (CART_EFB_BASE + $75)   ; EFB Flash Interrupt Request Enable

; Enable WishBone connection
EFB_FLASH_ENABLE: macro
    ld a, (1 << CART_EFB_CFGCR_WBCE)
    ld [CART_EFB_CFGCR], a
endm

; Disable WishBone connection
EFB_FLASH_DISABLE: macro
    xor a,a
    ld [CART_EFB_CFGCR], a
endm

; Charmap for chars used in boot (very minimalistic)
newcharmap boot
charmap " ", $00
charmap "0", $01
charmap "1", $02
charmap "2", $03
charmap "3", $04
charmap "4", $05
charmap "5", $06
charmap "6", $07
charmap "7", $08
charmap "8", $09
charmap "9", $0A
charmap "A", $0B
charmap "B", $0C
charmap "C", $0D
charmap "D", $0E
charmap "E", $0F
charmap "F", $10
charmap "R", $11
charmap "W", $12
charmap ":", $13

section "Initialisation",rom0[$0150]

; Initialisation
__main::
    di                  ; Disable interrupts
    ld sp, stack_top    ; Initialise stack pointer

    ld a, $01
    ld [rIE], a         ; Enable VBL interrupt
    ei

    ; Disable LCD
    ld hl, rLCDC
    res 7, [hl]

    ; Copy chars to VRAM
    ld hl, chars_data
    ld a, [hl+]
    ld e, a
    ld a, [hl+]
    ld d, a
    ld b, h
    ld c, l
    ld hl, _VRAM
    call memcpy_wd

    ; Copy tile map to VRAM
    LOAD_CELL_SCRN0_HL 0,0
    ld bc, screen_data
    ld e, 18
.screen_copy:
    ld d, 20
    call memcpy

    ; Move hl to point to start of next line
    ld a, e
    ld de, 12
    add hl, de
    ld e, a
    
    ; Check loop counter e
    dec e
    jp nz, .screen_copy

    ; Initialise x coord
    ld a, $0C
    ldh [x_coord], a
    ld a, $06
    ldh [frame_delay], a

    ; Initialise selector location
    ld a, $05
    ldh [cursor_location], a

    ; Initialise previous button state
    ld a, $FF
    ldh [prev_button_state], a

    ; Enable LCD
    ld hl, rLCDC
    set 7, [hl]

    ; Initialise SPI
    xor a, a
    ld [CART_EFB_SPICR0], a
    ld [CART_EFB_SPICR1], a
    ld [CART_EFB_SPICR2], a

    ; SPI prescaler
    ;   53.2 MHz / 63 ~= 844.44 kHz
    ld a, $3F
    ld [CART_EFB_SPIBR], a
    
    ; Control register 2 values
    ;   - [7] Set in master mode
    ;   - [6] Hold CSS after transfer
    ;   - [5] Disable Lattice proprietary SPI extension
    ;   - [4] Reserved
    ;   - [3] Reserved
    ;   - [2] Active high clock
    ;   - [1] Data is captured on a leading (first) clock edge, and propagated on the opposite clock edge
    ;   - [0] Byte is sent MSB first
    ld a, %11000000
    ld [CART_EFB_SPICR2], a

    ; Control register 1 values
    ;   - [7] SPI enabled
    ;   - [6] User wake-up disabled
    ;   - [5] Enable configuration wake-up disabled
    ;   - [4] Reserved
    ;   - [3] Reserved
    ;   - [2] Reserved
    ;   - [1] Reserved
    ;   - [0] Reserved
    ld a, %10000000
    ld [CART_EFB_SPICR1], a

    ; ; Transmit a byte
    ; ld a, $55
    ; ld [CART_EFB_SPITXDR], a

; 	; Code to read 1 page from UFM0

;     EFB_FLASH_ENABLE

;     ; Enable WishBone connection
;     ld hl, flash_cmd_enable
;     ld d, 4
;     call efb_flash_write

;     EFB_FLASH_DISABLE

; .read_status:
;     EFB_FLASH_ENABLE

;     ; Read status
;     ld hl, flash_cmd_status
;     ld d, 4
;     call efb_flash_write
;     ld hl, flash_rdata_status
;     ld d, 4
;     call efb_flash_read

;     EFB_FLASH_DISABLE

;     ; Check for busy bit
;     ld a, [flash_rdata_status + 2]
;     bit 4, a
;     jp nz, .read_status

;     EFB_FLASH_ENABLE

;     ; Set UFM0 address to 0
;     ld hl, flash_cmd_set_ufm0_addr
;     ld d, 8
;     call efb_flash_write

;     EFB_FLASH_DISABLE
;     EFB_FLASH_ENABLE

;     ; Read 1 page of data
;     ld hl, flash_cmd_read_page
;     ld d, 4
;     call efb_flash_write
;     ld hl, flash_rdata_page
;     ld d, 16
;     call efb_flash_read

;     EFB_FLASH_DISABLE
;     EFB_FLASH_ENABLE

;     ; Disable WishBone connection
;     ld hl, flash_cmd_disable
;     ld d, 3
;     call efb_flash_write

;     EFB_FLASH_DISABLE
;     EFB_FLASH_ENABLE

;     ; Send NOOP (necessary after disable)
;     ld a, $FF
;     ld [CART_EFB_CFGTXDR], a

;     EFB_FLASH_DISABLE

;     ; At this point, the page data should be at flash_rdata_page

.frame_tick:
    halt
    nop

    call handle_button_press

    ; Check frame delay
    ldh a, [frame_delay]
    dec a
    ldh [frame_delay], a
    jp nz, .frame_tick

    ; Reset frame delay
    ld a, $06
    ldh [frame_delay], a

    call update_crawl

    jp .frame_tick

perform_read_transaction:
    call load_transaction_info    

    ; Perform the transaction
    ld e, [hl]
    push de
    push hl

    ; Scroll the screen
    call scroll_history
    pop hl
    pop de

    ; Write upper address byte to screen
    ld d, h
    call d2hex
    ld a, b
    ld [$9821], a
    ld a, c
    ld [$9822], a

    ; Write lower address byte to screen
    ld d, l
    call d2hex
    ld a, b
    ld [$9823], a
    ld a, c
    ld [$9824], a

    ; Write data byte to screen
    ld d, e
    call d2hex
    ld a, b
    ld [$9826], a
    ld a, c
    ld [$9827], a

    ; Write 'R' to indicate read
    ld a, "R"
    ld [$9829], a

    ; Enable LCD
    ld hl, rLCDC
    set 7, [hl]

    ret

perform_write_transaction:
    call load_transaction_info    

    ; Perform the transaction
    ld e, a
    ld [hl], e
    push de
    push hl

    ; Scroll the screen
    call scroll_history
    pop hl
    pop de

    ; Write upper address byte to screen
    ld d, h
    call d2hex
    ld a, b
    ld [$9821], a
    ld a, c
    ld [$9822], a

    ; Write lower address byte to screen
    ld d, l
    call d2hex
    ld a, b
    ld [$9823], a
    ld a, c
    ld [$9824], a

    ; Write data byte to screen
    ld d, e
    call d2hex
    ld a, b
    ld [$9826], a
    ld a, c
    ld [$9827], a

    ; Write 'W' to indicate write
    ld a, "W"
    ld [$9829], a

    ; Enable LCD
    ld hl, rLCDC
    set 7, [hl]

    ret
    
; Load transaction info from screen
;   hl - will contain the address
;   a - will contain the data (used on write)
load_transaction_info:
    ld hl, $982F
    call hstr2a
    ldh [transaction_address+1], a
    call hstr2a
    ldh [transaction_address], a
    ld hl, $9871
    call hstr2a
    ld d, a

    ; Load transaction address to hl
    ld a, [transaction_address]
    ld l, a
    ld a, [transaction_address+1]
    ld h, a
    ld a, d

    ret

; Convert a hex string to its binairy counterpart in a register
;   hl - pointer to the start of the string
;
;   a - will contain the result
hstr2a:
    ld a, [hl+]
    ld b, a
    ld a, [hl+]
    ld c, a
    call hex2d
    ld a, d

    ret

; Scroll history of transactions situated left of the screen
scroll_history:
    ; Halt till next VBlank, then disable LCD
    halt
    nop
    ld hl, rLCDC
    res 7, [hl]

    ld hl, $9A2A
    ld e, 15
.scroll_loop:
    ld d, 9
    push de
    ld de, $FFB7    ; Decrement to start of 2 lines above
    add hl, de
    ld b, h
    ld c, l         ; bc now contains pointer to start of src line
    ld de, $0020
    add hl, de      ; hl now contains pointer to start of dest line
    pop de
    call memcpy

    dec e           ; Loop counter
    jr nz, .scroll_loop

    ret

handle_button_press:
    ; Read button state and check for press/release events
    call check_button_event

    ; Load selector location pointer
    ldh a, [cursor_location]
    ld c, a
    call get_cursor_pointer

    ; Clear cursor in place
    xor a, a
    ld [hl], a
    ld d, a

    ; Check for left press
    bit 5, b
    jr z, .check_right_press
    dec c
    bit 7, c
    jr z, .done_checking_press
    ld c, $05
    jr .done_checking_press

.check_right_press:
    bit 4, b
    jr z, .check_up_press
    inc c
    ld a, $06
    cp a, c
    jr nz, .done_checking_press
    xor a, a
    ld c, a
    jr .done_checking_press

.check_up_press:
    bit 6, b
    jr z, .check_down_press
    call get_pointer_below_cursor
    ld a, [hl]
    inc a
    ld e, $11
    cp a, e
    jr nz, .skip_value_overflow
    xor a, a
    inc a
.skip_value_overflow:
    ld [hl], a
    jr .done_checking_press

.check_down_press:
    bit 7, b
    jr z, .check_a_press
    call get_pointer_below_cursor
    ld a, [hl]
    dec a
    jr nz, .skip_value_underflow
    ld a, $10
.skip_value_underflow:
    ld [hl], a
    jr .done_checking_press

.check_a_press:
    bit 0, b
    jr z, .check_b_press
    call perform_read_transaction
    ldh a, [cursor_location]    ; Cursor location has not changed
    ld c, a                     ; So load original
    jr .done_checking_press

.check_b_press:
    bit 1, b
    jr z, .done_checking_press
    call perform_write_transaction
    ldh a, [cursor_location]    ; Cursor location has not changed
    ld c, a                     ; So load original

.done_checking_press:

    ; Place cursor
    ld a, c
    call get_cursor_pointer
    ld a, $15
    ld [hl], a

    ; Store selector location
    ld a, c
    ldh [cursor_location], a

    ret

; Get one of the VRAM pointers to cursor locations
;   a - must contain the index into `cursor_locations`
;   hl - will contain the pointer after execution
get_cursor_pointer:
    ld hl, cursor_locations
    add a, l
    ld l, a
    jr nc, .skip_high_increment
    inc h
.skip_high_increment
    ld a, [hl]
    ld h, $98
    ld l, a

    ret

; Well, exactly what the name implies
;   hl - must be the pointer to the cursor
;   hl - will contain the aformentioned pointer after execution
get_pointer_below_cursor:
    xor a, a
    ld d, a
    ld e, $20
    add hl, de

    ret

; Update moving char to indicate GameBoy is functioning normally
update_crawl:
    ; Initialise screen pointer
    ld h, $9A
    ldh a, [x_coord]
    ld l, a

    ; Check if coordinate needs to roll over
    xor a, a
    ld [hl], a
    inc l
    ld a, l
    cp a, $13
    jp nz, .skip_rollover

    ld a, $0C
    ld l, a

.skip_rollover:
    ldh [x_coord], a

    ; Write char to screen
    ld a, $01
    ld [hl], a

    ret

; Check for button events
;   b - will contain the same bitmap as a in read_buttons, but set bits are
;       buttons pressed
;   c - will contain the same bitmap as a in read_buttons, but set bits are
;       buttons released
check_button_event:
    call read_buttons
    ld hl, prev_button_state

    ld d, [hl]  ; d holds previous state
    ld [hl], a  ; Save current state for next use
    ld e, a     ; e holds current state

    xor a, d    ; Changed bits will be set
    ld c, a

    and a, d    ; Bits previously set and changed (press)
    ld b, a
    ld a, c
    and a, e    ; Bits previously clear and changed (release)
    ld c, a

    ret

; Read from buttons and store result in a
;   a[7] - Start
;   a[6] - Select
;   a[5] - B
;   a[4] - A
;   a[3] - Down
;   a[2] - Up
;   a[1] - Left
;   a[0] - Right
read_buttons:
    ld hl, rP1

    ; Read from directional buttons
    set 4, [hl]
    ld a, [hl]
    ld a, [hl]
    ld a, [hl]
    and a, $0F
    ld b, a
    res 4, [hl]

    ; Read from action buttons
    set 5, [hl]     
    ld a, [hl]
    ld a, [hl]
    ld a, [hl]
    and a, $0F
    res 5, [hl]

    swap a
    or a, b
    ret

; Write bytes to flash tx register
;   hl - pointer to data being writtten
;   d - number of bytes to write (must be > 0)
efb_flash_write:
    ld bc, CART_EFB_CFGTXDR
.copy_loop:
    ld a, [hl+]
    ld [bc], a
    dec d
    
    jp nz, .copy_loop
    ret

; Read bytes from flash rx register
;   hl - pointer to writable memory to store the read data
;   d - number of bytes to read (must be > 0)
efb_flash_read:
    ld bc, CART_EFB_CFGRXDR
.copy_loop:
    ld a, [bc]
    ld [hl+], a
    dec d
    
    jp nz, .copy_loop
    ret

; Convert a byte to its 2-byte text counterpart in hex using the boot charmap
;   d - byte to convert
;
;   bc - will contain the chars, b will contain it
;        for the upper 4 bits in d, c will contain it for
;        the lower 4 bits in d
d2hex:
    ; Load lower 4 bits into c and increment
    ld a, d
    and a, $0F
    ld c, a
    inc c

    ; Load upper 4 bits into b and increment
    ld a, d
    swap a
    and a, $0F
    ld b, a
    inc b

    ret

; Convert a 2-byte hex string to its binary counterpart in a register
;   bc - must contain the chars, b will contain it
;        for the upper 4 bits in a, c will contain it for
;        the lower 4 bits in a
;
;   d - will contain result byte
hex2d:
    ; Load upper 4-bits
    ld a, b
    dec a
    ld d, a
    swap d

    ; Load lower 4-bits
    ld a, c
    dec a
    or a, d
    ld d, a

    ret

; Memory copy - copies n bytes (8 bit) from src to dest, incrementing pointer
;   n    - [d] registers (n != 0)
;   src  - [bc] registers
;   dest - [hl] registers
memcpy:
    ld a, [bc]          ; Load from src
    ld [hl+], a         ; Copy to dest and increment pointer
    inc bc              ; Increment src pointer
    dec d               ; Decrement counter

    jp nz, memcpy       ; Keep copying if != 0
    ret

; Memory copy - copies n bytes (16 bit) from src to dest, incrementing pointer
;   n    - [de] registers (n != 0)
;   src  - [bc] registers
;   dest - [hl] registers
memcpy_wd:
    ld a, [bc]          ; Load from src
    ld [hl+], a         ; Copy to dest and increment pointer
    inc bc              ; Increment src pointer
    dec de              ; Decrement counter
	
    ; Compare de to 0
    xor a,a
    or a, e
    jp nz, memcpy_wd    ; Keep copying if != 0
    or a, d
    jp nz, memcpy_wd    ; Keep copying if != 0

    ret

; Memory set - sets n bytes (8 bit) at dest to x, incrementing pointer
;   n       - 'd' register (n != 0)
;   dest    - [hl] register
;   x       - 'a' register
memset:
    ld [hl+], a
    dec d
    jp nz, memset
    ret

section "Contant data",rom0

flash_cmd_enable:
    db $74,$08,$00,$00
flash_cmd_status:
    db $3C,$00,$00,$00
flash_cmd_set_ufm0_addr:
    db $B4,$00,$00,$00
    db $00,$00,$40,$00
flash_cmd_read_page:
    db $CA,$00,$00,$01
flash_cmd_disable:
    db $26,$00,$00

; Temporary test data
flash_rdata_page_rom:
    db $26,$EF,$72,$DE
    db $92,$EF,$72,$DA
    db $26,$40,$72,$ED
    db $2B,$00,$72,$00

cursor_locations:
    db $0F,$10,$11,$12,$51,$52

section "Variable data",hram

x_coord:
    ds 1
frame_delay:
    ds 1
prev_button_state:
    ds 1
cursor_location:
    ds 1
transaction_address:
    ds 2

; union
; flash_rdata_status:
;     ds 4
; nextu
; flash_rdata_page:
;     ds 16
; endu
include "hardware.inc"
include "macros.inc"

; For EFB functions, refer to Using Hardend Control Functions MachXO3D Reference
; https://www.latticesemi.com/-/media/LatticeSemi/Documents/ApplicationNotes/UZ/FPGA-TN-02119-1-3-Using-Hardened-Control-Functions-MachXO3D-Reference.ashx?document_id=52704

; EFB Base address (might change upon firmware revision)
CART_EFB_BASE       equ $A000

; EFB SPI Registers
CART_EFB_SPICR0     equ (CART_EFB_BASE + $54)   ; EFB SPI Control Register 0
CART_EFB_SPICR1     equ (CART_EFB_BASE + $55)   ; EFB SPI Control Register 1
CART_EFB_SPICR2     equ (CART_EFB_BASE + $56)   ; EFB SPI Control Register 2
CART_EFB_SPIBR      equ (CART_EFB_BASE + $57)   ; EFB SPI Clock Pre-scale
CART_EFB_SPICSR     equ (CART_EFB_BASE + $58)   ; EFB SPI Chip Select
CART_EFB_SPITXDR    equ (CART_EFB_BASE + $59)   ; EFB SPI Transmit Data
CART_EFB_SPISR      equ (CART_EFB_BASE + $5A)   ; EFB SPI Status Register
CART_EFB_SPIRXDR    equ (CART_EFB_BASE + $5B)   ; EFB SPI Revieve Data
CART_EFB_SPIIRQ     equ (CART_EFB_BASE + $5C)   ; EFB SPI Interrupt Request
CART_EFB_SPIIRQEN   equ (CART_EFB_BASE + $5D)   ; EFB SPI Interrupt Request Enable

; EFB Flash Registers

; EFB Flash Control
CART_EFB_CFGCR      equ (CART_EFB_BASE + $70)
CART_EFB_CFGCR_WBCE equ 7   ; WISHBONE Connection Enable
CART_EFB_CFGCR_RSTE equ 6   ; WISHBONE Connection Reset

CART_EFB_CFGTXDR    equ (CART_EFB_BASE + $71)   ; EFB Flash Transmit Data
CART_EFB_CFGSR      equ (CART_EFB_BASE + $72)   ; EFB Flash Status
CART_EFB_CFGRXDR    equ (CART_EFB_BASE + $73)   ; EFB Flash Recieve Data
CART_EFB_CFGIRQ     equ (CART_EFB_BASE + $74)   ; EFB Flash Interrupt Request
CART_EFB_CFGIRQEN   equ (CART_EFB_BASE + $75)   ; EFB Flash Interrupt Request Enable

; Enable WishBone connection
EFB_FLASH_ENABLE: macro
    ld a, (1 << CART_EFB_CFGCR_WBCE)
    ld [CART_EFB_CFGCR], a
endm

; Disable WishBone connection
EFB_FLASH_DISABLE: macro
    xor a,a
    ld [CART_EFB_CFGCR], a
endm

; Charmap for chars used in boot (very minimalistic)
newcharmap boot
charmap "0", $00
charmap "1", $01
charmap "2", $02
charmap "3", $03
charmap "4", $04
charmap "5", $05
charmap "6", $06
charmap "7", $07
charmap "8", $08
charmap "9", $09
charmap "A", $0A
charmap "B", $0B
charmap "C", $0C
charmap "D", $0D
charmap "E", $0E
charmap "F", $0F

section "Initialisation",rom0[$0150]

; Initialisation
__main::
    di                  ; Disable interrupts
    ld sp, $FFFE        ; Initialise stack pointer

    ld a, $01
    ld [rIE], a         ; Enable VBL interrupt
    ei

    ; Disable LCD
    ld hl, rLCDC
    res 7, [hl]

    ; Copy chars to VRAM
    ld hl, chars_data
    ld a, [hl+]
    ld e, a
    ld a, [hl+]
    ld d, a
    ld b, h
    ld c, l
    ld hl, _VRAM
    call memcpy_wd

    ; Copy tile map to VRAM
    LOAD_CELL_SCRN0_HL 0,0
    ld bc, screen_data
    ld e, 18
.screen_copy:
    ld d, 20
    call memcpy

    ; Move hl to point to start of next line
    ld a, e
    ld de, 12
    add hl, de
    ld e, a
    
    ; Check loop counter e
    dec e
    jp nz, .screen_copy

    ; Initialise x coord
    ld a, $0C
    ld [x_coord], a
    ld a, $06
    ld [frame_delay], a

    ; Initialise selector location
    ld a, $98
    ld [cursor_location+1], a
    ld a, $12
    ld [cursor_location], a

    ; Initialise previous button state
    ld a, $FF
    ld [prev_button_state], a

    ; Initialise button events
    xor a, a
    ld [button_events], a
    ld [button_events+1], a

    ; Enable LCD
    ld hl, rLCDC
    set 7, [hl]

    ; Initialise SPI
    xor a, a
    ld [CART_EFB_SPICR0], a
    ld [CART_EFB_SPICR1], a
    ld [CART_EFB_SPICR2], a

    ; SPI prescaler
    ;   53.2 MHz / 63 ~= 844.44 kHz
    ld a, $3F
    ld [CART_EFB_SPIBR], a
    
    ; Control register 2 values
    ;   - [7] Set in master mode
    ;   - [6] Hold CSS after transfer
    ;   - [5] Disable Lattice proprietary SPI extension
    ;   - [4] Reserved
    ;   - [3] Reserved
    ;   - [2] Active high clock
    ;   - [1] Data is captured on a leading (first) clock edge, and propagated on the opposite clock edge
    ;   - [0] Byte is sent MSB first
    ld a, %11000000
    ld [CART_EFB_SPICR2], a

    ; Control register 2 values
    ;   - [7] SPI enabled
    ;   - [6] User wake-up disabled
    ;   - [5] Enable configuration wake-up disabled
    ;   - [4] Reserved
    ;   - [3] Reserved
    ;   - [2] Reserved
    ;   - [1] Reserved
    ;   - [0] Reserved
    ld a, %10000000
    ld [CART_EFB_SPICR1], a

    ; Transmit a byte
    ld a, $55
    ld [CART_EFB_SPITXDR], a

; 	; Code to read 1 page from UFM0

;     EFB_FLASH_ENABLE

;     ; Enable WishBone connection
;     ld hl, flash_cmd_enable
;     ld d, 4
;     call efb_flash_write

;     EFB_FLASH_DISABLE

; .read_status:
;     EFB_FLASH_ENABLE

;     ; Read status
;     ld hl, flash_cmd_status
;     ld d, 4
;     call efb_flash_write
;     ld hl, flash_rdata_status
;     ld d, 4
;     call efb_flash_read

;     EFB_FLASH_DISABLE

;     ; Check for busy bit
;     ld a, [flash_rdata_status + 2]
;     bit 4, a
;     jp nz, .read_status

;     EFB_FLASH_ENABLE

;     ; Set UFM0 address to 0
;     ld hl, flash_cmd_set_ufm0_addr
;     ld d, 8
;     call efb_flash_write

;     EFB_FLASH_DISABLE
;     EFB_FLASH_ENABLE

;     ; Read 1 page of data
;     ld hl, flash_cmd_read_page
;     ld d, 4
;     call efb_flash_write
;     ld hl, flash_rdata_page
;     ld d, 16
;     call efb_flash_read

;     EFB_FLASH_DISABLE
;     EFB_FLASH_ENABLE

;     ; Disable WishBone connection
;     ld hl, flash_cmd_disable
;     ld d, 3
;     call efb_flash_write

;     EFB_FLASH_DISABLE
;     EFB_FLASH_ENABLE

;     ; Send NOOP (necessary after disable)
;     ld a, $FF
;     ld [CART_EFB_CFGTXDR], a

;     EFB_FLASH_DISABLE

;     ; At this point, the page data should be at flash_rdata_page

.frame_tick:
    halt

    ; Check frame delay
    ld a, [frame_delay]
    dec a
    ld [frame_delay], a
    jp nz, .frame_tick

    ; Reset frame delay
    ld a, $06
    ld [frame_delay], a

    call update_crawl

    ; Read button state and check for press/release events
    call check_button_event
    ; ld a, c
    ; ld [button_events], a
    ld a, b
    ld [button_events+1], a

    ; Load selector location pointer
    ld a, [cursor_location]
    ld l, a
    ld a, [cursor_location+1]
    ld h, a

    ; Clear cursor in place
    xor a, a
    ld [hl], a
    ld d, a

    ; Check for left press
    bit 5, b
    jr z, .check_right_press
    ld a, $0F
    cp a, l     ; Check if cursor is upper left
    jr z, .check_right_press
    ld a, $51
    cp a, l     ; Check if cursor is lower left
    jr z, .check_right_press
    dec hl
    jr .done_checking_press

.check_right_press:
    bit 4, b
    jr z, .check_down_press
    ld a, $12
    cp a, l     ; Check if cursor is upper right
    jr z, .check_down_press
    ld a, $52
    cp a, l     ; Check if cursor is lower right
    jr z, .check_down_press
    inc hl
    jr .done_checking_press

.check_down_press:
    bit 7, b
    jr z, .check_up_press
    ld a, $11
    cp a, l     ; Check if cursor is above 2nd address digit
    jr z, .move_cursor_down
    ld a, $12
    cp a, l     ; Check if cursor is above 1st address digit
    jr z, .move_cursor_down
    jr .check_up_press

.move_cursor_down:
    ld e, $40
    add hl, de
    jr .done_checking_press

.check_up_press:
    bit 6, b
    jr z, .done_checking_press
    ld a, $51
    cp a, l     ; Check if cursor is above 2nd data digit
    jr z, .move_cursor_up
    ld a, $52
    cp a, l     ; Check if cursor is above 1st data digit
    jr z, .move_cursor_up
    jr .done_checking_press

.move_cursor_up:
    ld e, $C0
    add hl, de
    dec h
    jr .done_checking_press

.done_checking_press:

    ; Place cursor
    ld a, $15
    ld [hl], a

    ; Update cursor pointer
    ld a, l
    ld [cursor_location], a
    ld a, h
    ld [cursor_location+1], a

    jp .frame_tick

; Update moving char to indicate GameBoy is functioning normally
update_crawl:
    ; Initialise screen pointer
    ld h, $9A
    ld a, [x_coord]
    ld l, a

    ; Check if coordinate needs to roll over
    xor a, a
    ld [hl], a
    inc l
    ld a, l
    cp a, $13
    jp nz, .skip_rollover

    ld a, $0C
    ld l, a

.skip_rollover:
    ld [x_coord], a

    ; Write char to screen
    ld a, $01
    ld [hl], a

    ret

; Check for button events
;   b - will contain the same bitmap as a in read_buttons, but set bits are
;       buttons pressed
;   c - will contain the same bitmap as a in read_buttons, but set bits are
;       buttons released
check_button_event:
    call read_buttons
    ld hl, prev_button_state

    ld d, [hl]  ; d holds previous state
    ld [hl], a  ; Save current state for next use
    ld e, a     ; e holds current state

    xor a, d    ; Changed bits will be set
    ld c, a

    and a, d    ; Bits previously set and changed (press)
    ld b, a
    ld a, c
    and a, e    ; Bits previously clear and changed (release)
    ld c, a

    ret

; Read from buttons and store result in a
;   a[7] - Start
;   a[6] - Select
;   a[5] - B
;   a[4] - A
;   a[3] - Down
;   a[2] - Up
;   a[1] - Left
;   a[0] - Right
read_buttons:
    ld hl, rP1

    ; Read from directional buttons
    set 4, [hl]
    ld a, [hl]
    ld a, [hl]
    ld a, [hl]
    and a, $0F
    ld b, a
    res 4, [hl]

    ; Read from action buttons
    set 5, [hl]     
    ld a, [hl]
    ld a, [hl]
    ld a, [hl]
    and a, $0F
    res 5, [hl]

    swap a
    or a, b
    ret

; Write bytes to flash tx register
;   hl - pointer to data being writtten
;   d - number of bytes to write (must be > 0)
efb_flash_write:
    ld bc, CART_EFB_CFGTXDR
.copy_loop:
    ld a, [hl+]
    ld [bc], a
    dec d
    
    jp nz, .copy_loop
    ret

; Read bytes from flash rx register
;   hl - pointer to writable memory to store the read data
;   d - number of bytes to read (must be > 0)
efb_flash_read:
    ld bc, CART_EFB_CFGRXDR
.copy_loop:
    ld a, [bc]
    ld [hl+], a
    dec d
    
    jp nz, .copy_loop
    ret

; Convert a byte to its 2-byte text counterpart in hex using the boot charmap
;   d - byte to convert
;
;   bc - will contain the chars, b will contain it
;        for the upper 4 bits in a, c will contain it for
;        the lower 4 bits in a
d2hex:
    ; Load lower 4 bits into c and increment
    ld a, d
    and a, $0F
    ld c, a
    inc c

    ; Load upper 4 bits into b and increment
    ld a, d
    swap a
    and a, $0F
    ld b, a
    inc b

    ret

; Memory copy - copies n bytes (8 bit) from src to dest, incrementing pointer
;   n    - [d] registers (n != 0)
;   src  - [bc] registers
;   dest - [hl] registers
memcpy:
    ld a, [bc]          ; Load from src
    ld [hl+], a         ; Copy to dest and increment pointer
    inc bc              ; Increment src pointer
    dec d               ; Decrement counter

    jp nz, memcpy       ; Keep copying if != 0
    ret

; Memory copy - copies n bytes (16 bit) from src to dest, incrementing pointer
;   n    - [de] registers (n != 0)
;   src  - [bc] registers
;   dest - [hl] registers
memcpy_wd:
    ld a, [bc]          ; Load from src
    ld [hl+], a         ; Copy to dest and increment pointer
    inc bc              ; Increment src pointer
    dec de              ; Decrement counter
	
    ; Compare de to 0
    xor a,a
    or a, e
    jp nz, memcpy_wd    ; Keep copying if != 0
    or a, d
    jp nz, memcpy_wd    ; Keep copying if != 0

    ret

; Memory set - sets n bytes (8 bit) at dest to x, incrementing pointer
;   n       - 'd' register (n != 0)
;   dest    - [hl] register
;   x       - 'a' register
memset:
    ld [hl+], a
    dec d
    jp nz, memset
    ret

section "Flash commands",rom0

flash_cmd_enable:
    db $74,$08,$00,$00
flash_cmd_status:
    db $3C,$00,$00,$00
flash_cmd_set_ufm0_addr:
    db $B4,$00,$00,$00
    db $00,$00,$40,$00
flash_cmd_read_page:
    db $CA,$00,$00,$01
flash_cmd_disable:
    db $26,$00,$00

; Temporary test data
flash_rdata_page_rom:
    db $26,$EF,$72,$DE
    db $92,$EF,$72,$DA
    db $26,$40,$72,$ED
    db $2B,$00,$72,$00

section "Variable data",wram0

x_coord:
    ds 1
frame_delay:
    ds 1
prev_button_state:
    ds 1
button_events:
    ds 2
cursor_location:
    ds 2

union
flash_rdata_status:
    ds 4
nextu
flash_rdata_page:
    ds 16
endu